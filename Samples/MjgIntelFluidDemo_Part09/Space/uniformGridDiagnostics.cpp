/*! \file uniformGridDiagnostics.cpp

    \brief Diagnostic routines for UniformGrids of vectors or matrices

    \see Accompanying articles for more information:
        http://software.intel.com/en-us/articles/fluid-simulation-for-video-games-part-1/
        http://software.intel.com/en-us/articles/fluid-simulation-for-video-games-part-2/
        http://software.intel.com/en-us/articles/fluid-simulation-for-video-games-part-3/
        http://software.intel.com/en-us/articles/fluid-simulation-for-video-games-part-4/
        http://software.intel.com/en-us/articles/fluid-simulation-for-video-games-part-5/
        http://software.intel.com/en-us/articles/fluid-simulation-for-video-games-part-6/
        http://software.intel.com/en-us/articles/fluid-simulation-for-video-games-part-7/
        http://software.intel.com/en-us/articles/fluid-simulation-for-video-games-part-8/
        http://software.intel.com/en-us/articles/fluid-simulation-for-video-games-part-9/

        http://www.gamasutra.com/view/feature/4164/sponsored_feature_fluid_.php
        http://www.gamasutra.com/view/feature/4176/sponsored_feature_fluid_.php

        http://www.mijagourlay.com/

    \author Copyright 2009-2010 Dr. Michael Jason Gourlay; All rights reserved.
*/

#include "Core/Math/mat33.h"

#include "uniformGrid.h"
#include "uniformGridMath.h"





/*! \brief Generate brick-of-bytes volumetric data file, for a scalar quantity

    \param strFilenameBase - prefix of name of files to write.
        This string precedes both data and script file names.

    \param uFrame - frame number.  Used to generate data filenames.

    This routine also appends filenames to an OGLE script file named "<strFilenameBase>.ogle".

    Example OGLE script file preamble which can make use of the files this routine generates:

    \verbatim

windowSize: 512 512
Transform: { angles 270 0 0 } 
#
dataView: Opacity_Renderer[0] subset.selected_var = 0
dataView: Opacity_Renderer[0] colormap.alpha      = 0.5
dataView: Opacity_Renderer[0] colormap[0].type    = COLORMAP_SPECTRUM
dataView: Opacity_Renderer[0] colormap[1].alpha   = 0.6
dataView: Opacity_Renderer[0] colormap[2].alpha   = 0.7
dataView: Opacity_Renderer[0] active              = true
#
# Entries for various data sets:
#
# (Append contents of file generated by this routine.)

    \endverbatim

*/
void UniformGrid<float>::GenerateBrickOfBytes( const char * strFilenameBase , unsigned uFrame ) const
{
#if ! defined( _XBOX )
    // Compute min, max values of values.
    float fMin=FLT_MAX, fMax=-fMin ;
    ComputeStatistics( fMin , fMax ) ;
#if ENFORCE_SYMMETRIC_RANGE
    const float fExtreme = MAX2( -fMin , fMax ) ;
    fMax = fExtreme ;
    fMin = - fMax ;
#endif
    const float        fRange = MAX2( fMax - fMin , FLT_MIN ) ; // FLT_MIN is to avoid divide-by-zero below.

    // Create name of data file.
    char strDataFilename[ 256 ] ;
    sprintf( strDataFilename , "Vols/%s%05u-%ux%ux%u.dat" , strFilenameBase , uFrame , GetNumPoints( 0 ) , GetNumPoints( 1 ) , GetNumPoints( 2 ) ) ;
    {
        // Append data filename to script file.
        char strScriptFilename[ 256 ] ;
        sprintf( strScriptFilename , "%s.ogle" , strFilenameBase ) ;
        FILE * pScriptFile = fopen( strScriptFilename , "a" ) ;
        if( ! pScriptFile ) {  return ; }
        // Write comment to script file indicating vector value ranges
        fprintf( pScriptFile , "# %s ranges: %9.7g to %9.7g\n" , strFilenameBase , fMin , fMax ) ;
        // Write to script file, names of vector component data files.
        fprintf( pScriptFile , "%ux%ux%u %s\n" , GetNumPoints( 0 ) , GetNumPoints( 1 ) , GetNumPoints( 2 ) , strDataFilename ) ;
        fclose( pScriptFile ) ;
    }

    // Open and populate data file.
    FILE * pDataFile ;
    pDataFile = fopen( strDataFilename , "wb" ) ;
    if( ! pDataFile ) {  return ; }

    static const float fAlmost256 = 256.0f * ( 1.0f - FLT_EPSILON ) ;

    const size_t numGridPoints = Size() ;
    for( size_t offset = 0 ; offset < numGridPoints ; ++ offset )
    {
        const float  &  rVal        = (*this)[ offset ] ;
        const float     fShifted    = rVal - fMin ;
        const float     f0to1       = fShifted / fRange ;
        const float     f0to255     = f0to1 * fAlmost256 ;
        const int       iVal        = int( f0to255 ) ;
        unsigned char   cVal        = unsigned char( iVal ) ;
        fwrite( & cVal , 1 , 1 , pDataFile ) ;
    }

    // Write minimum and maximum values.
    // Without this, OGLE will interpret the value to be unsigned.
    fprintf( pDataFile , "MIN %g MAX %g\n" , fMin , fMax  ) ;

    // Close data file.
    fclose( pDataFile ) ;
#endif
}




/*! \brief Compute statistics of data in a uniform grid of 3-vectors

    \param min - minimum of all values in grid.

    \param max - maximum of all values in grid.

*/
void UniformGrid<Vec3>::ComputeStatistics( Vec3 & min , Vec3 & max ) const
{
    min = Vec3( FLT_MAX , FLT_MAX , FLT_MAX ) ;
    max = Vec3( -min ) ;
    const unsigned dims[3] = { GetNumPoints( 0 ) , GetNumPoints( 1 ) , GetNumPoints( 2 ) } ;
    const unsigned numXY   = dims[0] * dims[1] ;
    unsigned index[3] ;

    for( index[2] = 0 ; index[2] < dims[2] ; ++ index[2] )
    {
        const unsigned offsetPartialZ = numXY * index[2]       ;
        for( index[1] = 0 ; index[1] < dims[1] ; ++ index[1] )
        {
            const unsigned offsetPartialYZ = dims[ 0 ] * index[1] + offsetPartialZ ;
            for( index[0] = 0 ; index[0] < dims[0] ; ++ index[0] )
            {
                const unsigned offset = index[0]     + offsetPartialYZ  ;
                const Vec3 & rVal = (*this)[ offset ] ;
                min.x = MIN2( min.x , rVal.x ) ;
                min.y = MIN2( min.y , rVal.y ) ;
                min.z = MIN2( min.z , rVal.z ) ;
                max.x = MAX2( max.x , rVal.x ) ;
                max.y = MAX2( max.y , rVal.y ) ;
                max.z = MAX2( max.z , rVal.z ) ;
            }
        }
    }
}




/*! \brief Generate brick-of-bytes volumetric data files, one per component of vector and another for magnitude.

    \param strFilenameBase - prefix of name of file to write

    \param uFrame - frame number.  Used to generate filenames.

    This routine also appends filenames to an OGLE script file.

    Example OGLE script file which can make use of the files this routine generates:

    \verbatim

windowSize: 512 512
Transform: { angles 270 0 0 } 
#
dataView: Streamline[0] subset.x_range = 31 32 4
dataView: Streamline[0] subset.y_range = 54 57 4
dataView: Streamline[0] subset.z_range =  7 10 4
dataView: Streamline[0] colormap.type  = COLORMAP_SPECTRUM
dataView: Streamline[0] criterion      = STREAMLINE_CRITERION_ALL
dataView: Streamline[0] decimation     = 5
dataView: Streamline[0] active         = true
#
dataView: Vector_Field subset.selected_var = 0
dataView: Vector_Field subset.x_stride = 2
dataView: Vector_Field subset.y_stride = 2
dataView: Vector_Field subset.z_stride = 2
dataView: Vector_Field colormap.type   = COLORMAP_HOT_COLD
dataView: Vector_Field vector_glyph    = HEDGEHOG_VECTOR_CONES_SOLID_LIT
dataView: Vector_Field active          = true
#
dataView: Opacity_Renderer[0] subset.selected_var = -1
dataView: Opacity_Renderer[0] colormap.alpha      = 0.5
dataView: Opacity_Renderer[0] colormap[0].type    = COLORMAP_SPECTRUM
dataView: Opacity_Renderer[0] colormap[1].alpha   = 0.6
dataView: Opacity_Renderer[0] colormap[2].alpha   = 0.7
dataView: Opacity_Renderer[0] active              = true
#
# Entries for various data sets:
#
# (Append contents of file generated by this routine.)

    \endverbatim

*/
void UniformGrid<Vec3>::GenerateBrickOfBytes( const char * strFilenameBase , unsigned uFrame ) const
{
#if ! defined( _XBOX )
    // Compute min, max values of vector components.
    Vec3 vMin , vMax ;
    ComputeStatistics( vMin , vMax ) ;
    Vec3        vExtreme( MAX2( -vMin.x , vMax.x ) , MAX2( -vMin.y , vMax.y ) , MAX2( -vMin.z , vMax.z ) ) ;
    const float fMagMax = vExtreme.Magnitude() ; // Not the correct value for |v|_max but a reasonable approximation for visualization purposes.
#if ENFORCE_SYMMETRIC_RANGE
    vMax = vExtreme ;
    vMin = - vMax ;
#endif
    Vec3        vRange( vMax - vMin ) ;
    vRange.x = MAX2( FLT_MIN , vRange.x ) ;  // Avoid divide-by-zero below
    vRange.y = MAX2( FLT_MIN , vRange.y ) ;  // Avoid divide-by-zero below
    vRange.z = MAX2( FLT_MIN , vRange.z ) ;  // Avoid divide-by-zero below

    // Create names of data files.
    char strDataFilenames[4][ 256 ] ;
    sprintf( strDataFilenames[0] , "Vols/%sX%05u-%ux%ux%u.dat" , strFilenameBase , uFrame , GetNumPoints( 0 ) , GetNumPoints( 1 ) , GetNumPoints( 2 ) ) ;
    sprintf( strDataFilenames[1] , "Vols/%sY%05u-%ux%ux%u.dat" , strFilenameBase , uFrame , GetNumPoints( 0 ) , GetNumPoints( 1 ) , GetNumPoints( 2 ) ) ;
    sprintf( strDataFilenames[2] , "Vols/%sZ%05u-%ux%ux%u.dat" , strFilenameBase , uFrame , GetNumPoints( 0 ) , GetNumPoints( 1 ) , GetNumPoints( 2 ) ) ;
    sprintf( strDataFilenames[3] , "Vols/%sM%05u-%ux%ux%u.dat" , strFilenameBase , uFrame , GetNumPoints( 0 ) , GetNumPoints( 1 ) , GetNumPoints( 2 ) ) ;
    {
        // Append data filenames to script file.
        char strScriptFilename[ 256 ] ;
        sprintf( strScriptFilename , "%s.ogle" , strFilenameBase ) ;
        FILE * pScriptFile = fopen( strScriptFilename , "a" ) ;
        // Write comment to script file indicating vector value ranges
        fprintf( pScriptFile , "# %s ranges: {%9.7g,%9.7g,%9.7g} to {%9.7g,%9.7g,%9.7g}\n" , strFilenameBase , vMin.x , vMin.y , vMin.z , vMax.x , vMax.y , vMax.z ) ;
        // Write to script file, names of vector component data files.
        fprintf( pScriptFile , "%ux%ux%u %s %s %s\n" , GetNumPoints( 0 ) , GetNumPoints( 1 ) , GetNumPoints( 2 ) , strDataFilenames[0] , strDataFilenames[1] , strDataFilenames[2] ) ;
        // Write to script file, name of magnitude data file.
        // fprintf( pScriptFile , "%ux%ux%u %s\n" , GetNumPoints( 0 ) , GetNumPoints( 1 ) , GetNumPoints( 2 ) , strDataFilenames[3] ) ;
        fclose( pScriptFile ) ;
    }

    // Open and populate data files.
    FILE * pDataFiles[4] ;
    pDataFiles[0] = fopen( strDataFilenames[0] , "wb" ) ; 
    pDataFiles[1] = fopen( strDataFilenames[1] , "wb" ) ;
    pDataFiles[2] = fopen( strDataFilenames[2] , "wb" ) ;
    pDataFiles[3] = fopen( strDataFilenames[3] , "wb" ) ;
    if( ! pDataFiles[0] ) {  return ; }    // If this fails, inspect the filenames and check to see whether the subdirectory exists.
    if( ! pDataFiles[1] ) {  return ; }
    if( ! pDataFiles[2] ) {  return ; }
    if( ! pDataFiles[3] ) {  return ; }

    static const float fAlmost256 = 256.0f * ( 1.0f - FLT_EPSILON ) ;

    const size_t numGridPoints = Size() ;
    for( size_t offset = 0 ; offset < numGridPoints ; ++ offset )
    {
        const Vec3   &  rVec            = (*this)[ offset ] ;
        const float     fMag            = rVec.Magnitude() ;
        const Vec3      vShifted        = rVec - vMin ;
        const Vec3      v0to1        = Vec3( vShifted.x / vRange.x , vShifted.y / vRange.y , vShifted.z / vRange.z ) ;
        const Vec3      v0to255      = v0to1 * fAlmost256 ;
        const float     vMag0to255   = fAlmost256 * fMag / ( fMagMax + FLT_MIN ) ;
        //printf( "vF %3g %3g %3g %3g %3g\n", v0to255.x , v0to255.y , v0to255.z , vMag0to255 ) ;
        int iVec[4] = { int( v0to255.x ) , int( v0to255.y ) , int( v0to255.z ) , int( vMag0to255 ) } ;
    #if ENFORCE_SYMMETRIC_RANGE
    #endif
        //printf( "vI %3i %3i %3i %3i\n", iVec[0] , iVec[1] , iVec[2] , iVec[3] ) ;
        unsigned char cVec[4] = { unsigned char( iVec[0] ) , unsigned char( iVec[1] ) , unsigned char( iVec[2] ) , unsigned char( iVec[3] ) } ;
        fwrite( & cVec[0] , 1 , 1 , pDataFiles[0] ) ;
        fwrite( & cVec[1] , 1 , 1 , pDataFiles[1] ) ;
        fwrite( & cVec[2] , 1 , 1 , pDataFiles[2] ) ;
        fwrite( & cVec[3] , 1 , 1 , pDataFiles[3] ) ;
        //printf( "vC %3u %3u %3u %3u\n", cVec[0] , cVec[1] , cVec[2] , cVec[3] ) ;
    }

    // Write minimum and maximum values for each component.
    // Without this, OGLE will interpret the value to be signed, when used with hedgehog and streamline dataviews.
    fprintf( pDataFiles[0] , "MIN %g MAX %g\n" , vMin.x , vMax.x  ) ;
    fprintf( pDataFiles[1] , "MIN %g MAX %g\n" , vMin.y , vMax.y  ) ;
    fprintf( pDataFiles[2] , "MIN %g MAX %g\n" , vMin.z , vMax.z  ) ;
    fprintf( pDataFiles[3] , "MIN %g MAX %g\n" , 0      , fMagMax ) ;

    // Close data files.
    fclose( pDataFiles[0] ) ;
    fclose( pDataFiles[1] ) ;
    fclose( pDataFiles[2] ) ;
    fclose( pDataFiles[3] ) ;
#endif
}




inline float testFunc1D( float x           )           { return x * ( 4.0f - x * 4.0f ) ; }

inline float testFunc2D( float x , float y )           { return testFunc1D( x ) * testFunc1D( y ) ; }

inline float testFunc3D( float x , float y , float z ) { return testFunc2D( x , y ) * testFunc1D( z ) ; }




/* static */ void UniformGrid<unsigned>::UnitTest( void )
{
}








// --------------------------

// Tests below assume grid spacing h==1/N+1 (i.e. there are NUM_PTS cells/intervals).

static const unsigned NX            = 64 ;
static const unsigned NY            = 16 ;
static const float    h[2]          = { 1.0f / float( NX - 1 ) , 1.0f / float( NY - 1 ) } ;
static const float    h2[2]         = { h[0] * h[0] , h[1] * h[1] } ;
static const float    oneOverH2[2]  = { 1.0f / h2[0] , 1.0f / h2[1] } ;
static const float    halfH2Sum     = 0.5f / ( oneOverH2[0] + oneOverH2[1] ) ;


inline float X( int i ) { return float( i ) * h[0] ; }
inline float Y( int i ) { return float( i ) * h[1] ; }


void ComputeLaplacian1D( float laplacian[ NX ] , const float func[ NX ] )
{
    for( unsigned i = 1 ; i < NX - 1 ; ++ i )
    {
        laplacian[ i ] = ( func[ i+1 ] + func[ i-1 ] - 2.0f * func[ i ] ) * oneOverH2[0] ;
    }

#if 1
    // Use Dirichlet boundary conditions:
    // Assume func[boundary]==0.
    laplacian[ 0      ] = ( func[ 1      ] - 2.0f * func[ 0      ] ) * oneOverH2[0] ;
    laplacian[ NX - 1 ] = ( func[ NX - 2 ] - 2.0f * func[ NX - 1 ] ) * oneOverH2[0] ;
#elif 0
    // Use Neumann-ish boundary conditions:
    // -1 instead of -2 because we assume func[i]==func[boundary].
    laplacian[ 0      ] = ( func[ 1      ] - 1.0f * func[ 0      ] ) * oneOverH2[0] ;
    laplacian[ NX - 1 ] = ( func[ NX - 2 ] - 1.0f * func[ NX - 1 ] ) * oneOverH2[0] ;
#else
    laplacian[ 0      ] = laplacian[ 1      ] ;
    laplacian[ NX - 1 ] = laplacian[ NX - 2 ] ;
#endif
}




void ComputeLaplacian2D( float laplacian[ NY ][ NX ] , const float func[ NY ][ NX ] )
{
    for( unsigned j = 1 ; j < NY - 1 ; ++ j )
    {
        for( unsigned i = 1 ; i < NX - 1 ; ++ i )
        {
            laplacian[ j ][ i ] =   ( func[ j   ][ i+1 ] + func[ j   ][ i-1 ] - 2.0f * func[ j ][ i ] ) * oneOverH2[0]
                                +   ( func[ j+1 ][ i   ] + func[ j-1 ][ i   ] - 2.0f * func[ j ][ i ] ) * oneOverH2[1]
                                ;
        }
    }

#if 1
    // Use Dirichlet boundary conditions:
    // Assume func[boundary]==0.
    for( unsigned i = 0 ; i < NX ; ++ i )
    {
        laplacian[ 0      ][i] = ( func[ 1      ][i] - 2.0f * func[ 0      ][i] ) * oneOverH2[1] ;
        laplacian[ NY - 1 ][i] = ( func[ NY - 2 ][i] - 2.0f * func[ NY - 1 ][i] ) * oneOverH2[1] ;
    }
    for( unsigned j = 0 ; j < NY ; ++ j )
    {
        laplacian[j][ 0      ] = ( func[j][ 1      ] - 2.0f * func[j][ 0      ] ) * oneOverH2[0] ;
        laplacian[j][ NX - 1 ] = ( func[j][ NX - 2 ] - 2.0f * func[j][ NX - 1 ] ) * oneOverH2[0] ;
    }
#elif 0
    // Use Neumann-ish boundary conditions:
    // -1 instead of -2 because we assume func[i]==func[boundary].
    laplacian[ 0      ] = ( func[ 1      ] - 1.0f * func[ 0      ] ) * oneOverH2[0] ;
    laplacian[ NX - 1 ] = ( func[ NX - 2 ] - 1.0f * func[ NX - 1 ] ) * oneOverH2[0] ;
#else
    // "Gourlay" boundaries: second derivative is constant.
    for( unsigned i = 0 ; i < NX ; ++ i )
    {
        laplacian[ 0      ][ i ] = laplacian[ 1      ][ i ] ;
        laplacian[ NY - 1 ][ i ] = laplacian[ NY - 2 ][ i ] ;
    }
    for( unsigned j = 0 ; j < NY ; ++ j )
    {
        laplacian[ j ][ 0      ] = laplacian[ j ][ 1      ] ;
        laplacian[ j ][ NX - 1 ] = laplacian[ j ][ NX - 2 ] ;
    }
#endif
}




void SolvePoisson1D( float solution[ NX ] , const float laplacian[ NX ] )
{
    for( unsigned i = 1 ; i < NX - 1 ; ++ i )
    {
        // solution[ i ] = ( solution[ i+1 ] + solution[ i-1 ] ) * oneOverH2[0] - laplacian[ i ] ) * 0.5f * h2[0] ;
        solution[ i ] = ( solution[ i+1 ] + solution[ i-1 ] - laplacian[ i ] * h2[0] ) * 0.5f ;
    }
}




void SolvePoisson2D( float solution[ NY ][ NX ] , const float laplacian[ NY ][ NX ] )
{
    for( unsigned j = 1 ; j < NY - 1 ; ++ j )
    {
        for( unsigned i = 1 ; i < NX - 1 ; ++ i )
        {
            solution[ j ][ i ] = (   ( solution[ j   ][ i+1 ] + solution[ j   ][ i-1 ] ) * oneOverH2[0]
                                 +   ( solution[ j+1 ][ i   ] + solution[ j-1 ][ i   ] ) * oneOverH2[1]
                                 -   laplacian[ j ][ i ]
                                 ) * halfH2Sum
                                 ;
        }
    }
}




void PrintFunc1D( const float func[ NX ] , const char * filename )
{
    FILE * fp = fopen( filename , "w" ) ;
    for( unsigned i = 0 ; i < NX ; ++ i )
    {
        fprintf( fp , "%g\t%g\n" , X( i ) , func[ i ] ) ;
    }
    fclose( fp ) ;
}




void PrintFunc2D( const float func[ NY ][ NX ] , const char * filename )
{
    FILE * fp = fopen( filename , "w" ) ;

#define EXCEL_STYLE 1

#if EXCEL_STYLE
    fprintf( fp , "\t" ) ;
    for( unsigned i = 0 ; i < NX ; ++ i )
    {
        fprintf( fp , "%g\t" , X( i ) ) ;
    }
    fprintf( fp , "\n" ) ;
#endif

    for( unsigned j = 0 ; j < NY ; ++ j )
    {
        #if EXCEL_STYLE
            fprintf( fp , "%g\t" , Y( j ) ) ;
        #endif
        for( unsigned i = 0 ; i < NX ; ++ i )
        {
            #if EXCEL_STYLE
                fprintf( fp , "%g\t" , func[ j ][ i ] ) ;
            #else
                fprintf( fp , "%g\t%g\t%g\n" , X( i ) , Y( i ) , func[ j ][ i ] ) ;
            #endif
        }
        #if EXCEL_STYLE
            fprintf( fp , "\n" ) ;
        #endif
    }
    fclose( fp ) ;
}




void UniformGrid_AssignTestValues( UniformGrid<Vec3> & ugv3 )
{
    unsigned        idx[3] ;   // Grid cell indices.
    for( idx[2] = 0 ; idx[2] < ugv3.GetNumPoints( 2 ) ; ++ idx[2] )
    {   // For each point along z axis...
        Vec3 vPos   ; // Position of point within UniformGrid.
        Vec3 vParam ; // Parametric coordinate of vPosition
        vParam.z = float( idx[2] ) / float( ugv3.GetNumCells(2) ) ;
        vPos.z = ugv3.GetMinCorner().z + float( idx[2] ) * ugv3.GetCellSpacing().z ;
        for( idx[1] = 0 ; idx[1] < ugv3.GetNumPoints( 1 ) ; ++ idx[1] )
        {   // For each point along y axis...
            vParam.y = float( idx[1] ) / float( ugv3.GetNumCells(1) ) ;
            vPos.y = ugv3.GetMinCorner().y + float( idx[1] ) * ugv3.GetCellSpacing().y ;
            for( idx[0] = 0 ; idx[0] < ugv3.GetNumPoints( 0 ) ; ++ idx[0] )
            {   // For each point along x axis...
                vParam.x = float( idx[0] ) / float( ugv3.GetNumCells(0) ) ;
                vPos.x = ugv3.GetMinCorner().x + float( idx[0] ) * ugv3.GetCellSpacing().x ;
                const Vec3 funcVal(   testFunc1D( vParam.x )
                                    , testFunc2D( vParam.x , vParam.y )
                                    , testFunc3D( vParam.x , vParam.y , vParam.z )
                                    );
                ugv3[ idx ] = funcVal ;
            }
        }
    }
}




void UnitTestPoisson1D( void )
{
    float func[ NX ] ;

    for( unsigned i = 0 ; i < NX ; ++ i )
    {
        func[ i ] = testFunc1D( X( i ) ) ; // effectively, func( x ) = x^2
    }
    PrintFunc1D( func , "func.dat" ) ;

    float laplacian[ NX ] ;
    ComputeLaplacian1D( laplacian , func ) ;
    PrintFunc1D( laplacian , "laplacian.dat" ) ;

    float funcSolved[ NX ] ;
    for( unsigned i = 0 ; i < NX ; ++ i )
    {
        funcSolved[ i ] = 0.0f ;    // Initialize the trial solution
    }
    for( unsigned iter = 0 ; iter < NX * NX ; ++ iter )
    {
        //char filename[ 256 ] ;
        //sprintf( filename , "funcSoln%04i.dat" , iter ) ;
        //PrintFunc1D( funcSolved , filename ) ;
        SolvePoisson1D( funcSolved , laplacian ) ;
    }
    PrintFunc1D( funcSolved , "funcSoln.dat" ) ;
}



void UnitTestPoisson2D( void )
{
    float func[ NY ][ NX ] ;

    for( unsigned j = 0 ; j < NY ; ++ j )
    {
        for( unsigned i = 0 ; i < NX ; ++ i )
        {
            func[ j ][ i ] = testFunc2D( X( i ) , Y( j ) ) ;
        }
    }
    PrintFunc2D( func , "func2d.dat" ) ;

    float laplacian[ NY ][ NX ] ;
    ComputeLaplacian2D( laplacian , func ) ;
    PrintFunc2D( laplacian , "laplacian2.dat" ) ;

    float funcSolved[ NY ][ NX ] ;
    for( unsigned j = 0 ; j < NY ; ++ j )
    {
        for( unsigned i = 0 ; i < NX ; ++ i )
        {
            funcSolved[ j ][ i ] = 0.0f ;    // Initialize the trial solution
        }
    }
    for( unsigned iter = 0 ; iter < NX * NY ; ++ iter )
    {
        //char filename[ 256 ] ;
        //sprintf( filename , "funcSoln%04i.dat" , iter ) ;
        //PrintFunc2D( funcSolved , filename ) ;
        SolvePoisson2D( funcSolved , laplacian ) ;
    }
    PrintFunc2D( funcSolved , "funcSoln2.dat" ) ;
}
